// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fafnir/api-gateway/graph/model"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	HasPermissionResponse struct {
		HasPermission  func(childComplexity int) int
		PermissionCode func(childComplexity int) int
	}

	ProfileDataResponse struct {
		FirstName      func(childComplexity int) int
		LastName       func(childComplexity int) int
		PermissionCode func(childComplexity int) int
		UserID         func(childComplexity int) int
	}

	Query struct {
		CheckPermission        func(childComplexity int, request model.HasPermissionRequest) int
		GetProfileData         func(childComplexity int, userID string) int
		GetStockHistoricalData func(childComplexity int, symbol string, period *string) int
		GetStockMetadata       func(childComplexity int, symbol string) int
		GetStockQuote          func(childComplexity int, symbol string) int
		Health                 func(childComplexity int) int
	}

	StockData struct {
		Currency         func(childComplexity int) int
		Exchange         func(childComplexity int) int
		ExchangeFullName func(childComplexity int) int
		Name             func(childComplexity int) int
		Symbol           func(childComplexity int) int
	}

	StockHistoricalData struct {
		Change        func(childComplexity int) int
		ChangePercent func(childComplexity int) int
		Close         func(childComplexity int) int
		Date          func(childComplexity int) int
		High          func(childComplexity int) int
		Low           func(childComplexity int) int
		Open          func(childComplexity int) int
		Symbol        func(childComplexity int) int
		Volume        func(childComplexity int) int
	}

	StockHistoricalDataResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}

	StockMetadataResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}

	StockPriceData struct {
		DayHigh            func(childComplexity int) int
		DayLow             func(childComplexity int) int
		MarketCap          func(childComplexity int) int
		Open               func(childComplexity int) int
		PreviousClose      func(childComplexity int) int
		Price              func(childComplexity int) int
		PriceChange        func(childComplexity int) int
		PriceChangePercent func(childComplexity int) int
		Symbol             func(childComplexity int) int
		Volume             func(childComplexity int) int
		YearHigh           func(childComplexity int) int
		YearLow            func(childComplexity int) int
	}

	StockQuoteResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "HasPermissionResponse.hasPermission":
		if e.complexity.HasPermissionResponse.HasPermission == nil {
			break
		}

		return e.complexity.HasPermissionResponse.HasPermission(childComplexity), true

	case "HasPermissionResponse.permissionCode":
		if e.complexity.HasPermissionResponse.PermissionCode == nil {
			break
		}

		return e.complexity.HasPermissionResponse.PermissionCode(childComplexity), true

	case "ProfileDataResponse.firstName":
		if e.complexity.ProfileDataResponse.FirstName == nil {
			break
		}

		return e.complexity.ProfileDataResponse.FirstName(childComplexity), true

	case "ProfileDataResponse.lastName":
		if e.complexity.ProfileDataResponse.LastName == nil {
			break
		}

		return e.complexity.ProfileDataResponse.LastName(childComplexity), true

	case "ProfileDataResponse.permissionCode":
		if e.complexity.ProfileDataResponse.PermissionCode == nil {
			break
		}

		return e.complexity.ProfileDataResponse.PermissionCode(childComplexity), true

	case "ProfileDataResponse.userId":
		if e.complexity.ProfileDataResponse.UserID == nil {
			break
		}

		return e.complexity.ProfileDataResponse.UserID(childComplexity), true

	case "Query.checkPermission":
		if e.complexity.Query.CheckPermission == nil {
			break
		}

		args, err := ec.field_Query_checkPermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CheckPermission(childComplexity, args["request"].(model.HasPermissionRequest)), true

	case "Query.getProfileData":
		if e.complexity.Query.GetProfileData == nil {
			break
		}

		args, err := ec.field_Query_getProfileData_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProfileData(childComplexity, args["userId"].(string)), true

	case "Query.getStockHistoricalData":
		if e.complexity.Query.GetStockHistoricalData == nil {
			break
		}

		args, err := ec.field_Query_getStockHistoricalData_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStockHistoricalData(childComplexity, args["symbol"].(string), args["period"].(*string)), true

	case "Query.getStockMetadata":
		if e.complexity.Query.GetStockMetadata == nil {
			break
		}

		args, err := ec.field_Query_getStockMetadata_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStockMetadata(childComplexity, args["symbol"].(string)), true

	case "Query.getStockQuote":
		if e.complexity.Query.GetStockQuote == nil {
			break
		}

		args, err := ec.field_Query_getStockQuote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStockQuote(childComplexity, args["symbol"].(string)), true

	case "Query.health":
		if e.complexity.Query.Health == nil {
			break
		}

		return e.complexity.Query.Health(childComplexity), true

	case "StockData.currency":
		if e.complexity.StockData.Currency == nil {
			break
		}

		return e.complexity.StockData.Currency(childComplexity), true

	case "StockData.exchange":
		if e.complexity.StockData.Exchange == nil {
			break
		}

		return e.complexity.StockData.Exchange(childComplexity), true

	case "StockData.exchangeFullName":
		if e.complexity.StockData.ExchangeFullName == nil {
			break
		}

		return e.complexity.StockData.ExchangeFullName(childComplexity), true

	case "StockData.name":
		if e.complexity.StockData.Name == nil {
			break
		}

		return e.complexity.StockData.Name(childComplexity), true

	case "StockData.symbol":
		if e.complexity.StockData.Symbol == nil {
			break
		}

		return e.complexity.StockData.Symbol(childComplexity), true

	case "StockHistoricalData.change":
		if e.complexity.StockHistoricalData.Change == nil {
			break
		}

		return e.complexity.StockHistoricalData.Change(childComplexity), true

	case "StockHistoricalData.changePercent":
		if e.complexity.StockHistoricalData.ChangePercent == nil {
			break
		}

		return e.complexity.StockHistoricalData.ChangePercent(childComplexity), true

	case "StockHistoricalData.close":
		if e.complexity.StockHistoricalData.Close == nil {
			break
		}

		return e.complexity.StockHistoricalData.Close(childComplexity), true

	case "StockHistoricalData.date":
		if e.complexity.StockHistoricalData.Date == nil {
			break
		}

		return e.complexity.StockHistoricalData.Date(childComplexity), true

	case "StockHistoricalData.high":
		if e.complexity.StockHistoricalData.High == nil {
			break
		}

		return e.complexity.StockHistoricalData.High(childComplexity), true

	case "StockHistoricalData.low":
		if e.complexity.StockHistoricalData.Low == nil {
			break
		}

		return e.complexity.StockHistoricalData.Low(childComplexity), true

	case "StockHistoricalData.open":
		if e.complexity.StockHistoricalData.Open == nil {
			break
		}

		return e.complexity.StockHistoricalData.Open(childComplexity), true

	case "StockHistoricalData.symbol":
		if e.complexity.StockHistoricalData.Symbol == nil {
			break
		}

		return e.complexity.StockHistoricalData.Symbol(childComplexity), true

	case "StockHistoricalData.volume":
		if e.complexity.StockHistoricalData.Volume == nil {
			break
		}

		return e.complexity.StockHistoricalData.Volume(childComplexity), true

	case "StockHistoricalDataResponse.code":
		if e.complexity.StockHistoricalDataResponse.Code == nil {
			break
		}

		return e.complexity.StockHistoricalDataResponse.Code(childComplexity), true

	case "StockHistoricalDataResponse.data":
		if e.complexity.StockHistoricalDataResponse.Data == nil {
			break
		}

		return e.complexity.StockHistoricalDataResponse.Data(childComplexity), true

	case "StockMetadataResponse.code":
		if e.complexity.StockMetadataResponse.Code == nil {
			break
		}

		return e.complexity.StockMetadataResponse.Code(childComplexity), true

	case "StockMetadataResponse.data":
		if e.complexity.StockMetadataResponse.Data == nil {
			break
		}

		return e.complexity.StockMetadataResponse.Data(childComplexity), true

	case "StockPriceData.dayHigh":
		if e.complexity.StockPriceData.DayHigh == nil {
			break
		}

		return e.complexity.StockPriceData.DayHigh(childComplexity), true

	case "StockPriceData.dayLow":
		if e.complexity.StockPriceData.DayLow == nil {
			break
		}

		return e.complexity.StockPriceData.DayLow(childComplexity), true

	case "StockPriceData.marketCap":
		if e.complexity.StockPriceData.MarketCap == nil {
			break
		}

		return e.complexity.StockPriceData.MarketCap(childComplexity), true

	case "StockPriceData.open":
		if e.complexity.StockPriceData.Open == nil {
			break
		}

		return e.complexity.StockPriceData.Open(childComplexity), true

	case "StockPriceData.previousClose":
		if e.complexity.StockPriceData.PreviousClose == nil {
			break
		}

		return e.complexity.StockPriceData.PreviousClose(childComplexity), true

	case "StockPriceData.price":
		if e.complexity.StockPriceData.Price == nil {
			break
		}

		return e.complexity.StockPriceData.Price(childComplexity), true

	case "StockPriceData.priceChange":
		if e.complexity.StockPriceData.PriceChange == nil {
			break
		}

		return e.complexity.StockPriceData.PriceChange(childComplexity), true

	case "StockPriceData.priceChangePercent":
		if e.complexity.StockPriceData.PriceChangePercent == nil {
			break
		}

		return e.complexity.StockPriceData.PriceChangePercent(childComplexity), true

	case "StockPriceData.symbol":
		if e.complexity.StockPriceData.Symbol == nil {
			break
		}

		return e.complexity.StockPriceData.Symbol(childComplexity), true

	case "StockPriceData.volume":
		if e.complexity.StockPriceData.Volume == nil {
			break
		}

		return e.complexity.StockPriceData.Volume(childComplexity), true

	case "StockPriceData.yearHigh":
		if e.complexity.StockPriceData.YearHigh == nil {
			break
		}

		return e.complexity.StockPriceData.YearHigh(childComplexity), true

	case "StockPriceData.yearLow":
		if e.complexity.StockPriceData.YearLow == nil {
			break
		}

		return e.complexity.StockPriceData.YearLow(childComplexity), true

	case "StockQuoteResponse.code":
		if e.complexity.StockQuoteResponse.Code == nil {
			break
		}

		return e.complexity.StockQuoteResponse.Code(childComplexity), true

	case "StockQuoteResponse.data":
		if e.complexity.StockQuoteResponse.Data == nil {
			break
		}

		return e.complexity.StockQuoteResponse.Data(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputHasPermissionRequest,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/base.graphqls", Input: `schema {
    query: Query
}

type Query
`, BuiltIn: false},
	{Name: "../schemas/health.graphqls", Input: `extend type Query {
    health: String!
}`, BuiltIn: false},
	{Name: "../schemas/security.graphqls", Input: `input HasPermissionRequest {
    userId: String!
    permission: String!
}

type HasPermissionResponse {
    hasPermission: Boolean!
    permissionCode: String! # grpc permission code (e.g., "PERMISSION_DENIED")
}

extend type Query {
    checkPermission(request: HasPermissionRequest!): HasPermissionResponse!
}`, BuiltIn: false},
	{Name: "../schemas/stock.graphqls", Input: `scalar Int64

type StockMetadataResponse {
    code: Int!
    data: StockData!
}

type StockQuoteResponse {
    code: Int!
    data: StockPriceData!
}

type StockHistoricalDataResponse {
    code: Int!
    data: [StockHistoricalData!]!
}

type StockData {
    symbol: String!
    name: String!
    exchange: String!
    exchangeFullName: String!
    currency: String!
}

type StockHistoricalData {
    symbol: String!
    date: String!
    open: Float!
    high: Float!
    low: Float!
    close: Float!
    volume: Int64!
    change: Float!
    changePercent: Float!
}

type StockPriceData {
    symbol: String!
    price: Float!
    open: Float!
    previousClose: Float!
    priceChange: Float!
    priceChangePercent: Float!
    volume: Int64!
    marketCap: Float!
    dayLow: Float!
    dayHigh: Float!
    yearHigh: Float!
    yearLow: Float!
}

extend type Query {
    getStockMetadata(symbol: String!): StockMetadataResponse!
    getStockQuote(symbol: String!): StockQuoteResponse!
    getStockHistoricalData(symbol: String!, period: String): StockHistoricalDataResponse!
}`, BuiltIn: false},
	{Name: "../schemas/user.graphqls", Input: `type ProfileDataResponse {
    userId: String!
    firstName: String!
    lastName: String!
    permissionCode: String! # grpc permission code
}

extend type Query {
    getProfileData(userId: String!): ProfileDataResponse!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
