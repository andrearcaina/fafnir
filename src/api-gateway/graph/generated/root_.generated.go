// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fafnir/api-gateway/graph/model"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CancelOrderResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}

	CreateOrderResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}

	HasPermissionResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}

	Mutation struct {
		CancelOrder func(childComplexity int, orderID string) int
		CreateOrder func(childComplexity int, request model.CreateOrderRequest) int
	}

	Order struct {
		AvgFillPrice   func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		FilledQuantity func(childComplexity int) int
		ID             func(childComplexity int) int
		Price          func(childComplexity int) int
		Quantity       func(childComplexity int) int
		Side           func(childComplexity int) int
		Status         func(childComplexity int) int
		StopPrice      func(childComplexity int) int
		Symbol         func(childComplexity int) int
		Type           func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
		UserID         func(childComplexity int) int
	}

	OrdersResponse struct {
		Code  func(childComplexity int) int
		Count func(childComplexity int) int
		Data  func(childComplexity int) int
	}

	ProfileData struct {
		FirstName func(childComplexity int) int
		LastName  func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	ProfileDataResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}

	Query struct {
		CheckPermission        func(childComplexity int, request model.HasPermissionRequest) int
		GetOrders              func(childComplexity int) int
		GetProfileData         func(childComplexity int) int
		GetStockHistoricalData func(childComplexity int, symbol string, period *string) int
		GetStockMetadata       func(childComplexity int, symbol string) int
		GetStockQuote          func(childComplexity int, symbol string) int
		GetStockQuoteBatch     func(childComplexity int, symbols []string) int
		Health                 func(childComplexity int) int
	}

	SecurityPermission struct {
		HasPermission func(childComplexity int) int
	}

	StockData struct {
		Currency         func(childComplexity int) int
		Exchange         func(childComplexity int) int
		ExchangeFullName func(childComplexity int) int
		Name             func(childComplexity int) int
		Symbol           func(childComplexity int) int
	}

	StockHistoricalData struct {
		Close              func(childComplexity int) int
		Date               func(childComplexity int) int
		High               func(childComplexity int) int
		Low                func(childComplexity int) int
		Open               func(childComplexity int) int
		PriceChange        func(childComplexity int) int
		PriceChangePercent func(childComplexity int) int
		Symbol             func(childComplexity int) int
		Volume             func(childComplexity int) int
	}

	StockHistoricalDataResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}

	StockMetadataResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}

	StockPriceData struct {
		DayHigh            func(childComplexity int) int
		DayLow             func(childComplexity int) int
		MarketCap          func(childComplexity int) int
		Open               func(childComplexity int) int
		PreviousClose      func(childComplexity int) int
		Price              func(childComplexity int) int
		PriceChange        func(childComplexity int) int
		PriceChangePercent func(childComplexity int) int
		Symbol             func(childComplexity int) int
		Volume             func(childComplexity int) int
		YearHigh           func(childComplexity int) int
		YearLow            func(childComplexity int) int
	}

	StockQuoteBatchResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}

	StockQuoteResponse struct {
		Code func(childComplexity int) int
		Data func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "CancelOrderResponse.code":
		if e.complexity.CancelOrderResponse.Code == nil {
			break
		}

		return e.complexity.CancelOrderResponse.Code(childComplexity), true

	case "CancelOrderResponse.data":
		if e.complexity.CancelOrderResponse.Data == nil {
			break
		}

		return e.complexity.CancelOrderResponse.Data(childComplexity), true

	case "CreateOrderResponse.code":
		if e.complexity.CreateOrderResponse.Code == nil {
			break
		}

		return e.complexity.CreateOrderResponse.Code(childComplexity), true

	case "CreateOrderResponse.data":
		if e.complexity.CreateOrderResponse.Data == nil {
			break
		}

		return e.complexity.CreateOrderResponse.Data(childComplexity), true

	case "HasPermissionResponse.code":
		if e.complexity.HasPermissionResponse.Code == nil {
			break
		}

		return e.complexity.HasPermissionResponse.Code(childComplexity), true

	case "HasPermissionResponse.data":
		if e.complexity.HasPermissionResponse.Data == nil {
			break
		}

		return e.complexity.HasPermissionResponse.Data(childComplexity), true

	case "Mutation.cancelOrder":
		if e.complexity.Mutation.CancelOrder == nil {
			break
		}

		args, err := ec.field_Mutation_cancelOrder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelOrder(childComplexity, args["orderId"].(string)), true

	case "Mutation.createOrder":
		if e.complexity.Mutation.CreateOrder == nil {
			break
		}

		args, err := ec.field_Mutation_createOrder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOrder(childComplexity, args["request"].(model.CreateOrderRequest)), true

	case "Order.avgFillPrice":
		if e.complexity.Order.AvgFillPrice == nil {
			break
		}

		return e.complexity.Order.AvgFillPrice(childComplexity), true

	case "Order.createdAt":
		if e.complexity.Order.CreatedAt == nil {
			break
		}

		return e.complexity.Order.CreatedAt(childComplexity), true

	case "Order.filledQuantity":
		if e.complexity.Order.FilledQuantity == nil {
			break
		}

		return e.complexity.Order.FilledQuantity(childComplexity), true

	case "Order.id":
		if e.complexity.Order.ID == nil {
			break
		}

		return e.complexity.Order.ID(childComplexity), true

	case "Order.price":
		if e.complexity.Order.Price == nil {
			break
		}

		return e.complexity.Order.Price(childComplexity), true

	case "Order.quantity":
		if e.complexity.Order.Quantity == nil {
			break
		}

		return e.complexity.Order.Quantity(childComplexity), true

	case "Order.side":
		if e.complexity.Order.Side == nil {
			break
		}

		return e.complexity.Order.Side(childComplexity), true

	case "Order.status":
		if e.complexity.Order.Status == nil {
			break
		}

		return e.complexity.Order.Status(childComplexity), true

	case "Order.stopPrice":
		if e.complexity.Order.StopPrice == nil {
			break
		}

		return e.complexity.Order.StopPrice(childComplexity), true

	case "Order.symbol":
		if e.complexity.Order.Symbol == nil {
			break
		}

		return e.complexity.Order.Symbol(childComplexity), true

	case "Order.type":
		if e.complexity.Order.Type == nil {
			break
		}

		return e.complexity.Order.Type(childComplexity), true

	case "Order.updatedAt":
		if e.complexity.Order.UpdatedAt == nil {
			break
		}

		return e.complexity.Order.UpdatedAt(childComplexity), true

	case "Order.userId":
		if e.complexity.Order.UserID == nil {
			break
		}

		return e.complexity.Order.UserID(childComplexity), true

	case "OrdersResponse.code":
		if e.complexity.OrdersResponse.Code == nil {
			break
		}

		return e.complexity.OrdersResponse.Code(childComplexity), true

	case "OrdersResponse.count":
		if e.complexity.OrdersResponse.Count == nil {
			break
		}

		return e.complexity.OrdersResponse.Count(childComplexity), true

	case "OrdersResponse.data":
		if e.complexity.OrdersResponse.Data == nil {
			break
		}

		return e.complexity.OrdersResponse.Data(childComplexity), true

	case "ProfileData.firstName":
		if e.complexity.ProfileData.FirstName == nil {
			break
		}

		return e.complexity.ProfileData.FirstName(childComplexity), true

	case "ProfileData.lastName":
		if e.complexity.ProfileData.LastName == nil {
			break
		}

		return e.complexity.ProfileData.LastName(childComplexity), true

	case "ProfileData.userId":
		if e.complexity.ProfileData.UserID == nil {
			break
		}

		return e.complexity.ProfileData.UserID(childComplexity), true

	case "ProfileDataResponse.code":
		if e.complexity.ProfileDataResponse.Code == nil {
			break
		}

		return e.complexity.ProfileDataResponse.Code(childComplexity), true

	case "ProfileDataResponse.data":
		if e.complexity.ProfileDataResponse.Data == nil {
			break
		}

		return e.complexity.ProfileDataResponse.Data(childComplexity), true

	case "Query.checkPermission":
		if e.complexity.Query.CheckPermission == nil {
			break
		}

		args, err := ec.field_Query_checkPermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CheckPermission(childComplexity, args["request"].(model.HasPermissionRequest)), true

	case "Query.getOrders":
		if e.complexity.Query.GetOrders == nil {
			break
		}

		return e.complexity.Query.GetOrders(childComplexity), true

	case "Query.getProfileData":
		if e.complexity.Query.GetProfileData == nil {
			break
		}

		return e.complexity.Query.GetProfileData(childComplexity), true

	case "Query.getStockHistoricalData":
		if e.complexity.Query.GetStockHistoricalData == nil {
			break
		}

		args, err := ec.field_Query_getStockHistoricalData_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStockHistoricalData(childComplexity, args["symbol"].(string), args["period"].(*string)), true

	case "Query.getStockMetadata":
		if e.complexity.Query.GetStockMetadata == nil {
			break
		}

		args, err := ec.field_Query_getStockMetadata_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStockMetadata(childComplexity, args["symbol"].(string)), true

	case "Query.getStockQuote":
		if e.complexity.Query.GetStockQuote == nil {
			break
		}

		args, err := ec.field_Query_getStockQuote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStockQuote(childComplexity, args["symbol"].(string)), true

	case "Query.getStockQuoteBatch":
		if e.complexity.Query.GetStockQuoteBatch == nil {
			break
		}

		args, err := ec.field_Query_getStockQuoteBatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStockQuoteBatch(childComplexity, args["symbols"].([]string)), true

	case "Query.health":
		if e.complexity.Query.Health == nil {
			break
		}

		return e.complexity.Query.Health(childComplexity), true

	case "SecurityPermission.hasPermission":
		if e.complexity.SecurityPermission.HasPermission == nil {
			break
		}

		return e.complexity.SecurityPermission.HasPermission(childComplexity), true

	case "StockData.currency":
		if e.complexity.StockData.Currency == nil {
			break
		}

		return e.complexity.StockData.Currency(childComplexity), true

	case "StockData.exchange":
		if e.complexity.StockData.Exchange == nil {
			break
		}

		return e.complexity.StockData.Exchange(childComplexity), true

	case "StockData.exchangeFullName":
		if e.complexity.StockData.ExchangeFullName == nil {
			break
		}

		return e.complexity.StockData.ExchangeFullName(childComplexity), true

	case "StockData.name":
		if e.complexity.StockData.Name == nil {
			break
		}

		return e.complexity.StockData.Name(childComplexity), true

	case "StockData.symbol":
		if e.complexity.StockData.Symbol == nil {
			break
		}

		return e.complexity.StockData.Symbol(childComplexity), true

	case "StockHistoricalData.close":
		if e.complexity.StockHistoricalData.Close == nil {
			break
		}

		return e.complexity.StockHistoricalData.Close(childComplexity), true

	case "StockHistoricalData.date":
		if e.complexity.StockHistoricalData.Date == nil {
			break
		}

		return e.complexity.StockHistoricalData.Date(childComplexity), true

	case "StockHistoricalData.high":
		if e.complexity.StockHistoricalData.High == nil {
			break
		}

		return e.complexity.StockHistoricalData.High(childComplexity), true

	case "StockHistoricalData.low":
		if e.complexity.StockHistoricalData.Low == nil {
			break
		}

		return e.complexity.StockHistoricalData.Low(childComplexity), true

	case "StockHistoricalData.open":
		if e.complexity.StockHistoricalData.Open == nil {
			break
		}

		return e.complexity.StockHistoricalData.Open(childComplexity), true

	case "StockHistoricalData.priceChange":
		if e.complexity.StockHistoricalData.PriceChange == nil {
			break
		}

		return e.complexity.StockHistoricalData.PriceChange(childComplexity), true

	case "StockHistoricalData.priceChangePercent":
		if e.complexity.StockHistoricalData.PriceChangePercent == nil {
			break
		}

		return e.complexity.StockHistoricalData.PriceChangePercent(childComplexity), true

	case "StockHistoricalData.symbol":
		if e.complexity.StockHistoricalData.Symbol == nil {
			break
		}

		return e.complexity.StockHistoricalData.Symbol(childComplexity), true

	case "StockHistoricalData.volume":
		if e.complexity.StockHistoricalData.Volume == nil {
			break
		}

		return e.complexity.StockHistoricalData.Volume(childComplexity), true

	case "StockHistoricalDataResponse.code":
		if e.complexity.StockHistoricalDataResponse.Code == nil {
			break
		}

		return e.complexity.StockHistoricalDataResponse.Code(childComplexity), true

	case "StockHistoricalDataResponse.data":
		if e.complexity.StockHistoricalDataResponse.Data == nil {
			break
		}

		return e.complexity.StockHistoricalDataResponse.Data(childComplexity), true

	case "StockMetadataResponse.code":
		if e.complexity.StockMetadataResponse.Code == nil {
			break
		}

		return e.complexity.StockMetadataResponse.Code(childComplexity), true

	case "StockMetadataResponse.data":
		if e.complexity.StockMetadataResponse.Data == nil {
			break
		}

		return e.complexity.StockMetadataResponse.Data(childComplexity), true

	case "StockPriceData.dayHigh":
		if e.complexity.StockPriceData.DayHigh == nil {
			break
		}

		return e.complexity.StockPriceData.DayHigh(childComplexity), true

	case "StockPriceData.dayLow":
		if e.complexity.StockPriceData.DayLow == nil {
			break
		}

		return e.complexity.StockPriceData.DayLow(childComplexity), true

	case "StockPriceData.marketCap":
		if e.complexity.StockPriceData.MarketCap == nil {
			break
		}

		return e.complexity.StockPriceData.MarketCap(childComplexity), true

	case "StockPriceData.open":
		if e.complexity.StockPriceData.Open == nil {
			break
		}

		return e.complexity.StockPriceData.Open(childComplexity), true

	case "StockPriceData.previousClose":
		if e.complexity.StockPriceData.PreviousClose == nil {
			break
		}

		return e.complexity.StockPriceData.PreviousClose(childComplexity), true

	case "StockPriceData.price":
		if e.complexity.StockPriceData.Price == nil {
			break
		}

		return e.complexity.StockPriceData.Price(childComplexity), true

	case "StockPriceData.priceChange":
		if e.complexity.StockPriceData.PriceChange == nil {
			break
		}

		return e.complexity.StockPriceData.PriceChange(childComplexity), true

	case "StockPriceData.priceChangePercent":
		if e.complexity.StockPriceData.PriceChangePercent == nil {
			break
		}

		return e.complexity.StockPriceData.PriceChangePercent(childComplexity), true

	case "StockPriceData.symbol":
		if e.complexity.StockPriceData.Symbol == nil {
			break
		}

		return e.complexity.StockPriceData.Symbol(childComplexity), true

	case "StockPriceData.volume":
		if e.complexity.StockPriceData.Volume == nil {
			break
		}

		return e.complexity.StockPriceData.Volume(childComplexity), true

	case "StockPriceData.yearHigh":
		if e.complexity.StockPriceData.YearHigh == nil {
			break
		}

		return e.complexity.StockPriceData.YearHigh(childComplexity), true

	case "StockPriceData.yearLow":
		if e.complexity.StockPriceData.YearLow == nil {
			break
		}

		return e.complexity.StockPriceData.YearLow(childComplexity), true

	case "StockQuoteBatchResponse.code":
		if e.complexity.StockQuoteBatchResponse.Code == nil {
			break
		}

		return e.complexity.StockQuoteBatchResponse.Code(childComplexity), true

	case "StockQuoteBatchResponse.data":
		if e.complexity.StockQuoteBatchResponse.Data == nil {
			break
		}

		return e.complexity.StockQuoteBatchResponse.Data(childComplexity), true

	case "StockQuoteResponse.code":
		if e.complexity.StockQuoteResponse.Code == nil {
			break
		}

		return e.complexity.StockQuoteResponse.Code(childComplexity), true

	case "StockQuoteResponse.data":
		if e.complexity.StockQuoteResponse.Data == nil {
			break
		}

		return e.complexity.StockQuoteResponse.Data(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateOrderRequest,
		ec.unmarshalInputHasPermissionRequest,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/base.graphqls", Input: `schema {
    query: Query
    mutation: Mutation
}

type Query
type Mutation
`, BuiltIn: false},
	{Name: "../schemas/health.graphqls", Input: `extend type Query {
    health: String!
}`, BuiltIn: false},
	{Name: "../schemas/order.graphqls", Input: `type Order {
    id: String!
    userId: String!
    symbol: String!
    side: String!
    type: String!
    status: String!
    quantity: Float!
    price: Float!
    stopPrice: Float!
    filledQuantity: Float!
    avgFillPrice: Float!
    createdAt: String!
    updatedAt: String!
}

input CreateOrderRequest {
    symbol: String!
    side: String! 
    type: String!
    quantity: Float!
    price: Float
    stopPrice: Float
    status: String # optional, defaults to PENDING
}

type CreateOrderResponse {
    data: Order
    code: String!
}

type CancelOrderResponse {
    data: Order
    code: String!
}

type OrdersResponse {
    data: [Order!]
    count: Int!
    code: String!
}

extend type Query {
    getOrders: OrdersResponse!
}

extend type Mutation {
    createOrder(request: CreateOrderRequest!): CreateOrderResponse!
    cancelOrder(orderId: String!): CancelOrderResponse!
}
`, BuiltIn: false},
	{Name: "../schemas/security.graphqls", Input: `input HasPermissionRequest {
    permission: String!
}

type SecurityPermission {
    hasPermission: Boolean!
}

type HasPermissionResponse {
    data: SecurityPermission!
    code: String! # grpc permission code (e.g., "PERMISSION_DENIED")
}

extend type Query {
    checkPermission(request: HasPermissionRequest!): HasPermissionResponse!
}
`, BuiltIn: false},
	{Name: "../schemas/stock.graphqls", Input: `scalar Int64

type StockMetadataResponse {
    code: String!
    data: StockData
}

type StockQuoteResponse {
    code: String!
    data: StockPriceData
}

type StockQuoteBatchResponse {
    code: String!
    data: [StockPriceData]
}

type StockHistoricalDataResponse {
    code: String!
    data: [StockHistoricalData]
}

type StockData {
    symbol: String!
    name: String!
    exchange: String!
    exchangeFullName: String!
    currency: String!
}

type StockHistoricalData {
    symbol: String!
    date: String!
    open: Float!
    high: Float!
    low: Float!
    close: Float!
    volume: Int64!
    priceChange: Float!
    priceChangePercent: Float!
}

type StockPriceData {
    symbol: String!
    price: Float!
    open: Float!
    previousClose: Float!
    priceChange: Float!
    priceChangePercent: Float!
    volume: Int64!
    marketCap: Float!
    dayLow: Float!
    dayHigh: Float!
    yearHigh: Float!
    yearLow: Float!
}

extend type Query {
    getStockMetadata(symbol: String!): StockMetadataResponse!
    getStockQuote(symbol: String!): StockQuoteResponse!
    getStockHistoricalData(
        symbol: String!
        period: String
    ): StockHistoricalDataResponse!
    getStockQuoteBatch(symbols: [String!]!): StockQuoteBatchResponse!
}
`, BuiltIn: false},
	{Name: "../schemas/user.graphqls", Input: `type ProfileData {
    userId: String!
    firstName: String!
    lastName: String!
}

type ProfileDataResponse {
    data: ProfileData
    code: String! # grpc permission code
}

extend type Query {
    getProfileData: ProfileDataResponse!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
