// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: settlement.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const decreaseHolding = `-- name: DecreaseHolding :one
UPDATE holdings
SET quantity = quantity - $3, updated_at = NOW()
WHERE account_id = $1 AND symbol = $2
RETURNING id, account_id, symbol, quantity, avg_cost, created_at, updated_at
`

type DecreaseHoldingParams struct {
	AccountID uuid.UUID      `json:"account_id"`
	Symbol    string         `json:"symbol"`
	Quantity  pgtype.Numeric `json:"quantity"`
}

func (q *Queries) DecreaseHolding(ctx context.Context, arg DecreaseHoldingParams) (Holding, error) {
	row := q.db.QueryRow(ctx, decreaseHolding, arg.AccountID, arg.Symbol, arg.Quantity)
	var i Holding
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Symbol,
		&i.Quantity,
		&i.AvgCost,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAccountBalance = `-- name: UpdateAccountBalance :one
UPDATE accounts
SET 
    balance = balance + $2, 
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, account_number, account_type, currency, balance, created_at, updated_at
`

type UpdateAccountBalanceParams struct {
	ID      uuid.UUID      `json:"id"`
	Balance pgtype.Numeric `json:"balance"`
}

func (q *Queries) UpdateAccountBalance(ctx context.Context, arg UpdateAccountBalanceParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccountBalance, arg.ID, arg.Balance)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountNumber,
		&i.AccountType,
		&i.Currency,
		&i.Balance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertHolding = `-- name: UpsertHolding :one
INSERT INTO holdings (account_id, symbol, quantity, avg_cost, created_at, updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
ON CONFLICT (account_id, symbol)
DO UPDATE SET
    quantity = holdings.quantity + EXCLUDED.quantity,
    avg_cost = CASE
        WHEN holdings.quantity + EXCLUDED.quantity = 0 THEN 0
        ELSE (holdings.quantity * holdings.avg_cost + EXCLUDED.quantity * EXCLUDED.avg_cost) / (holdings.quantity + EXCLUDED.quantity)
    END,
    updated_at = NOW()
RETURNING id, account_id, symbol, quantity, avg_cost, created_at, updated_at
`

type UpsertHoldingParams struct {
	AccountID uuid.UUID      `json:"account_id"`
	Symbol    string         `json:"symbol"`
	Quantity  pgtype.Numeric `json:"quantity"`
	AvgCost   pgtype.Numeric `json:"avg_cost"`
}

func (q *Queries) UpsertHolding(ctx context.Context, arg UpsertHoldingParams) (Holding, error) {
	row := q.db.QueryRow(ctx, upsertHolding,
		arg.AccountID,
		arg.Symbol,
		arg.Quantity,
		arg.AvgCost,
	)
	var i Holding
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Symbol,
		&i.Quantity,
		&i.AvgCost,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
